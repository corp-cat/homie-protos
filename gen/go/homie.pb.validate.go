// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: homie.proto

package homie

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _homie_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on UVoteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UVoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UVoteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UVoteResponseMultiError, or
// nil if none found.
func (m *UVoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UVoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UVoteResponseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UVoteResponseMultiError(errors)
	}

	return nil
}

// UVoteResponseMultiError is an error wrapping multiple validation errors
// returned by UVoteResponse.ValidateAll() if the designated constraints
// aren't met.
type UVoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UVoteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UVoteResponseMultiError) AllErrors() []error { return m }

// UVoteResponseValidationError is the validation error returned by
// UVoteResponse.Validate if the designated constraints aren't met.
type UVoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UVoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UVoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UVoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UVoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UVoteResponseValidationError) ErrorName() string { return "UVoteResponseValidationError" }

// Error satisfies the builtin error interface
func (e UVoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUVoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UVoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UVoteResponseValidationError{}

// Validate checks the field values on CmVoteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CmVoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmVoteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CmVoteResponseMultiError,
// or nil if none found.
func (m *CmVoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CmVoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CmVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CmVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CmVoteResponseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CmVoteResponseMultiError(errors)
	}

	return nil
}

// CmVoteResponseMultiError is an error wrapping multiple validation errors
// returned by CmVoteResponse.ValidateAll() if the designated constraints
// aren't met.
type CmVoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmVoteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmVoteResponseMultiError) AllErrors() []error { return m }

// CmVoteResponseValidationError is the validation error returned by
// CmVoteResponse.Validate if the designated constraints aren't met.
type CmVoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmVoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmVoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmVoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmVoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmVoteResponseValidationError) ErrorName() string { return "CmVoteResponseValidationError" }

// Error satisfies the builtin error interface
func (e CmVoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmVoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmVoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmVoteResponseValidationError{}

// Validate checks the field values on PVoteCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PVoteCommentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PVoteCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PVoteCommentResponseMultiError, or nil if none found.
func (m *PVoteCommentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PVoteCommentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PVoteCommentResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PVoteCommentResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PVoteCommentResponseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PVoteCommentResponseMultiError(errors)
	}

	return nil
}

// PVoteCommentResponseMultiError is an error wrapping multiple validation
// errors returned by PVoteCommentResponse.ValidateAll() if the designated
// constraints aren't met.
type PVoteCommentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PVoteCommentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PVoteCommentResponseMultiError) AllErrors() []error { return m }

// PVoteCommentResponseValidationError is the validation error returned by
// PVoteCommentResponse.Validate if the designated constraints aren't met.
type PVoteCommentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PVoteCommentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PVoteCommentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PVoteCommentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PVoteCommentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PVoteCommentResponseValidationError) ErrorName() string {
	return "PVoteCommentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PVoteCommentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPVoteCommentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PVoteCommentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PVoteCommentResponseValidationError{}

// Validate checks the field values on PVoteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PVoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PVoteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PVoteResponseMultiError, or
// nil if none found.
func (m *PVoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PVoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PVoteResponseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PVoteResponseMultiError(errors)
	}

	return nil
}

// PVoteResponseMultiError is an error wrapping multiple validation errors
// returned by PVoteResponse.ValidateAll() if the designated constraints
// aren't met.
type PVoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PVoteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PVoteResponseMultiError) AllErrors() []error { return m }

// PVoteResponseValidationError is the validation error returned by
// PVoteResponse.Validate if the designated constraints aren't met.
type PVoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PVoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PVoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PVoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PVoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PVoteResponseValidationError) ErrorName() string { return "PVoteResponseValidationError" }

// Error satisfies the builtin error interface
func (e PVoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPVoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PVoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PVoteResponseValidationError{}

// Validate checks the field values on DVoteCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DVoteCommentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DVoteCommentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DVoteCommentResponseMultiError, or nil if none found.
func (m *DVoteCommentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DVoteCommentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DVoteCommentResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DVoteCommentResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DVoteCommentResponseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DVoteCommentResponseMultiError(errors)
	}

	return nil
}

// DVoteCommentResponseMultiError is an error wrapping multiple validation
// errors returned by DVoteCommentResponse.ValidateAll() if the designated
// constraints aren't met.
type DVoteCommentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DVoteCommentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DVoteCommentResponseMultiError) AllErrors() []error { return m }

// DVoteCommentResponseValidationError is the validation error returned by
// DVoteCommentResponse.Validate if the designated constraints aren't met.
type DVoteCommentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DVoteCommentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DVoteCommentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DVoteCommentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DVoteCommentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DVoteCommentResponseValidationError) ErrorName() string {
	return "DVoteCommentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DVoteCommentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDVoteCommentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DVoteCommentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DVoteCommentResponseValidationError{}

// Validate checks the field values on CVoteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CVoteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CVoteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CVoteResponseMultiError, or
// nil if none found.
func (m *CVoteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CVoteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CVoteResponseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CVoteResponseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CVoteResponseMultiError(errors)
	}

	return nil
}

// CVoteResponseMultiError is an error wrapping multiple validation errors
// returned by CVoteResponse.ValidateAll() if the designated constraints
// aren't met.
type CVoteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CVoteResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CVoteResponseMultiError) AllErrors() []error { return m }

// CVoteResponseValidationError is the validation error returned by
// CVoteResponse.Validate if the designated constraints aren't met.
type CVoteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CVoteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CVoteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CVoteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CVoteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CVoteResponseValidationError) ErrorName() string { return "CVoteResponseValidationError" }

// Error satisfies the builtin error interface
func (e CVoteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCVoteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CVoteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CVoteResponseValidationError{}

// Validate checks the field values on Votes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Votes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Votes with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VotesMultiError, or nil if none found.
func (m *Votes) ValidateAll() error {
	return m.validate(true)
}

func (m *Votes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Up

	// no validation rules for Down

	if len(errors) > 0 {
		return VotesMultiError(errors)
	}

	return nil
}

// VotesMultiError is an error wrapping multiple validation errors returned by
// Votes.ValidateAll() if the designated constraints aren't met.
type VotesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VotesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VotesMultiError) AllErrors() []error { return m }

// VotesValidationError is the validation error returned by Votes.Validate if
// the designated constraints aren't met.
type VotesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VotesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VotesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VotesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VotesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VotesValidationError) ErrorName() string { return "VotesValidationError" }

// Error satisfies the builtin error interface
func (e VotesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVotes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VotesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VotesValidationError{}

// Validate checks the field values on LoginResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResponseMultiError, or
// nil if none found.
func (m *LoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return LoginResponseMultiError(errors)
	}

	return nil
}

// LoginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResponseMultiError) AllErrors() []error { return m }

// LoginResponseValidationError is the validation error returned by
// LoginResponse.Validate if the designated constraints aren't met.
type LoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResponseValidationError) ErrorName() string { return "LoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e LoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResponseValidationError{}

// Validate checks the field values on RegisterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterResponseMultiError, or nil if none found.
func (m *RegisterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return RegisterResponseMultiError(errors)
	}

	return nil
}

// RegisterResponseMultiError is an error wrapping multiple validation errors
// returned by RegisterResponse.ValidateAll() if the designated constraints
// aren't met.
type RegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterResponseMultiError) AllErrors() []error { return m }

// RegisterResponseValidationError is the validation error returned by
// RegisterResponse.Validate if the designated constraints aren't met.
type RegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterResponseValidationError) ErrorName() string { return "RegisterResponseValidationError" }

// Error satisfies the builtin error interface
func (e RegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterResponseValidationError{}

// Validate checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenResponseMultiError, or nil if none found.
func (m *RefreshTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return RefreshTokenResponseMultiError(errors)
	}

	return nil
}

// RefreshTokenResponseMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenResponseMultiError) AllErrors() []error { return m }

// RefreshTokenResponseValidationError is the validation error returned by
// RefreshTokenResponse.Validate if the designated constraints aren't met.
type RefreshTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenResponseValidationError) ErrorName() string {
	return "RefreshTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenResponseValidationError{}

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for UserTag

	// no validation rules for Username

	// no validation rules for Email

	// no validation rules for About

	// no validation rules for Role

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BannedTo

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on UGetByTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UGetByTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UGetByTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UGetByTokenResponseMultiError, or nil if none found.
func (m *UGetByTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UGetByTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UGetByTokenResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UGetByTokenResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UGetByTokenResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UGetByTokenResponseMultiError(errors)
	}

	return nil
}

// UGetByTokenResponseMultiError is an error wrapping multiple validation
// errors returned by UGetByTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type UGetByTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UGetByTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UGetByTokenResponseMultiError) AllErrors() []error { return m }

// UGetByTokenResponseValidationError is the validation error returned by
// UGetByTokenResponse.Validate if the designated constraints aren't met.
type UGetByTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UGetByTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UGetByTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UGetByTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UGetByTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UGetByTokenResponseValidationError) ErrorName() string {
	return "UGetByTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UGetByTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUGetByTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UGetByTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UGetByTokenResponseValidationError{}

// Validate checks the field values on UGetByTagResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UGetByTagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UGetByTagResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UGetByTagResponseMultiError, or nil if none found.
func (m *UGetByTagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UGetByTagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UGetByTagResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UGetByTagResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UGetByTagResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CanEdit

	if len(errors) > 0 {
		return UGetByTagResponseMultiError(errors)
	}

	return nil
}

// UGetByTagResponseMultiError is an error wrapping multiple validation errors
// returned by UGetByTagResponse.ValidateAll() if the designated constraints
// aren't met.
type UGetByTagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UGetByTagResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UGetByTagResponseMultiError) AllErrors() []error { return m }

// UGetByTagResponseValidationError is the validation error returned by
// UGetByTagResponse.Validate if the designated constraints aren't met.
type UGetByTagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UGetByTagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UGetByTagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UGetByTagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UGetByTagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UGetByTagResponseValidationError) ErrorName() string {
	return "UGetByTagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UGetByTagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUGetByTagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UGetByTagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UGetByTagResponseValidationError{}

// Validate checks the field values on UDeleteFromCommunity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UDeleteFromCommunity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UDeleteFromCommunity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UDeleteFromCommunityMultiError, or nil if none found.
func (m *UDeleteFromCommunity) ValidateAll() error {
	return m.validate(true)
}

func (m *UDeleteFromCommunity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for CommunityUuid

	if len(errors) > 0 {
		return UDeleteFromCommunityMultiError(errors)
	}

	return nil
}

// UDeleteFromCommunityMultiError is an error wrapping multiple validation
// errors returned by UDeleteFromCommunity.ValidateAll() if the designated
// constraints aren't met.
type UDeleteFromCommunityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UDeleteFromCommunityMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UDeleteFromCommunityMultiError) AllErrors() []error { return m }

// UDeleteFromCommunityValidationError is the validation error returned by
// UDeleteFromCommunity.Validate if the designated constraints aren't met.
type UDeleteFromCommunityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UDeleteFromCommunityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UDeleteFromCommunityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UDeleteFromCommunityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UDeleteFromCommunityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UDeleteFromCommunityValidationError) ErrorName() string {
	return "UDeleteFromCommunityValidationError"
}

// Error satisfies the builtin error interface
func (e UDeleteFromCommunityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUDeleteFromCommunity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UDeleteFromCommunityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UDeleteFromCommunityValidationError{}

// Validate checks the field values on Community with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Community) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Community with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommunityMultiError, or nil
// if none found.
func (m *Community) ValidateAll() error {
	return m.validate(true)
}

func (m *Community) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for Title

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommunityValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommunityValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommunityValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Warnings

	// no validation rules for Price

	// no validation rules for AuthorTag

	// no validation rules for IsBanned

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return CommunityMultiError(errors)
	}

	return nil
}

// CommunityMultiError is an error wrapping multiple validation errors returned
// by Community.ValidateAll() if the designated constraints aren't met.
type CommunityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommunityMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommunityMultiError) AllErrors() []error { return m }

// CommunityValidationError is the validation error returned by
// Community.Validate if the designated constraints aren't met.
type CommunityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommunityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommunityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommunityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommunityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommunityValidationError) ErrorName() string { return "CommunityValidationError" }

// Error satisfies the builtin error interface
func (e CommunityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommunity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommunityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommunityValidationError{}

// Validate checks the field values on CmGetAllResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CmGetAllResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmGetAllResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmGetAllResponseMultiError, or nil if none found.
func (m *CmGetAllResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CmGetAllResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCommunities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CmGetAllResponseValidationError{
						field:  fmt.Sprintf("Communities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CmGetAllResponseValidationError{
						field:  fmt.Sprintf("Communities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CmGetAllResponseValidationError{
					field:  fmt.Sprintf("Communities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CmGetAllResponseMultiError(errors)
	}

	return nil
}

// CmGetAllResponseMultiError is an error wrapping multiple validation errors
// returned by CmGetAllResponse.ValidateAll() if the designated constraints
// aren't met.
type CmGetAllResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmGetAllResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmGetAllResponseMultiError) AllErrors() []error { return m }

// CmGetAllResponseValidationError is the validation error returned by
// CmGetAllResponse.Validate if the designated constraints aren't met.
type CmGetAllResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmGetAllResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmGetAllResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmGetAllResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmGetAllResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmGetAllResponseValidationError) ErrorName() string { return "CmGetAllResponseValidationError" }

// Error satisfies the builtin error interface
func (e CmGetAllResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmGetAllResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmGetAllResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmGetAllResponseValidationError{}

// Validate checks the field values on CmGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CmGetByUUIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmGetByUUIDResponseMultiError, or nil if none found.
func (m *CmGetByUUIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CmGetByUUIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommunity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CmGetByUUIDResponseValidationError{
					field:  "Community",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CmGetByUUIDResponseValidationError{
					field:  "Community",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommunity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CmGetByUUIDResponseValidationError{
				field:  "Community",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CmGetByUUIDResponseMultiError(errors)
	}

	return nil
}

// CmGetByUUIDResponseMultiError is an error wrapping multiple validation
// errors returned by CmGetByUUIDResponse.ValidateAll() if the designated
// constraints aren't met.
type CmGetByUUIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmGetByUUIDResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmGetByUUIDResponseMultiError) AllErrors() []error { return m }

// CmGetByUUIDResponseValidationError is the validation error returned by
// CmGetByUUIDResponse.Validate if the designated constraints aren't met.
type CmGetByUUIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmGetByUUIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmGetByUUIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmGetByUUIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmGetByUUIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmGetByUUIDResponseValidationError) ErrorName() string {
	return "CmGetByUUIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CmGetByUUIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmGetByUUIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmGetByUUIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmGetByUUIDResponseValidationError{}

// Validate checks the field values on CmGetAllWithFilterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CmGetAllWithFilterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmGetAllWithFilterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmGetAllWithFilterResponseMultiError, or nil if none found.
func (m *CmGetAllWithFilterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CmGetAllWithFilterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCommunities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CmGetAllWithFilterResponseValidationError{
						field:  fmt.Sprintf("Communities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CmGetAllWithFilterResponseValidationError{
						field:  fmt.Sprintf("Communities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CmGetAllWithFilterResponseValidationError{
					field:  fmt.Sprintf("Communities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CmGetAllWithFilterResponseMultiError(errors)
	}

	return nil
}

// CmGetAllWithFilterResponseMultiError is an error wrapping multiple
// validation errors returned by CmGetAllWithFilterResponse.ValidateAll() if
// the designated constraints aren't met.
type CmGetAllWithFilterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmGetAllWithFilterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmGetAllWithFilterResponseMultiError) AllErrors() []error { return m }

// CmGetAllWithFilterResponseValidationError is the validation error returned
// by CmGetAllWithFilterResponse.Validate if the designated constraints aren't met.
type CmGetAllWithFilterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmGetAllWithFilterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmGetAllWithFilterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmGetAllWithFilterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmGetAllWithFilterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmGetAllWithFilterResponseValidationError) ErrorName() string {
	return "CmGetAllWithFilterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CmGetAllWithFilterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmGetAllWithFilterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmGetAllWithFilterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmGetAllWithFilterResponseValidationError{}

// Validate checks the field values on CmCreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CmCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmCreateResponseMultiError, or nil if none found.
func (m *CmCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CmCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for CreatedAt

	// no validation rules for AuthorTag

	if len(errors) > 0 {
		return CmCreateResponseMultiError(errors)
	}

	return nil
}

// CmCreateResponseMultiError is an error wrapping multiple validation errors
// returned by CmCreateResponse.ValidateAll() if the designated constraints
// aren't met.
type CmCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmCreateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmCreateResponseMultiError) AllErrors() []error { return m }

// CmCreateResponseValidationError is the validation error returned by
// CmCreateResponse.Validate if the designated constraints aren't met.
type CmCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmCreateResponseValidationError) ErrorName() string { return "CmCreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e CmCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmCreateResponseValidationError{}

// Validate checks the field values on PostComment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PostComment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostComment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PostCommentMultiError, or
// nil if none found.
func (m *PostComment) ValidateAll() error {
	return m.validate(true)
}

func (m *PostComment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Body

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostCommentValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostCommentValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostCommentValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for AuthorTag

	if len(errors) > 0 {
		return PostCommentMultiError(errors)
	}

	return nil
}

// PostCommentMultiError is an error wrapping multiple validation errors
// returned by PostComment.ValidateAll() if the designated constraints aren't met.
type PostCommentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostCommentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostCommentMultiError) AllErrors() []error { return m }

// PostCommentValidationError is the validation error returned by
// PostComment.Validate if the designated constraints aren't met.
type PostCommentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostCommentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostCommentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostCommentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostCommentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostCommentValidationError) ErrorName() string { return "PostCommentValidationError" }

// Error satisfies the builtin error interface
func (e PostCommentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostComment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostCommentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostCommentValidationError{}

// Validate checks the field values on Post with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Post) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Post with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PostMultiError, or nil if none found.
func (m *Post) ValidateAll() error {
	return m.validate(true)
}

func (m *Post) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for CommunityUuid

	// no validation rules for Title

	// no validation rules for Body

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PostMultiError(errors)
	}

	return nil
}

// PostMultiError is an error wrapping multiple validation errors returned by
// Post.ValidateAll() if the designated constraints aren't met.
type PostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostMultiError) AllErrors() []error { return m }

// PostValidationError is the validation error returned by Post.Validate if the
// designated constraints aren't met.
type PostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostValidationError) ErrorName() string { return "PostValidationError" }

// Error satisfies the builtin error interface
func (e PostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostValidationError{}

// Validate checks the field values on PGetAllResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PGetAllResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PGetAllResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PGetAllResponseMultiError, or nil if none found.
func (m *PGetAllResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PGetAllResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPosts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PGetAllResponseValidationError{
						field:  fmt.Sprintf("Posts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PGetAllResponseValidationError{
						field:  fmt.Sprintf("Posts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PGetAllResponseValidationError{
					field:  fmt.Sprintf("Posts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PGetAllResponseMultiError(errors)
	}

	return nil
}

// PGetAllResponseMultiError is an error wrapping multiple validation errors
// returned by PGetAllResponse.ValidateAll() if the designated constraints
// aren't met.
type PGetAllResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PGetAllResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PGetAllResponseMultiError) AllErrors() []error { return m }

// PGetAllResponseValidationError is the validation error returned by
// PGetAllResponse.Validate if the designated constraints aren't met.
type PGetAllResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PGetAllResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PGetAllResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PGetAllResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PGetAllResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PGetAllResponseValidationError) ErrorName() string { return "PGetAllResponseValidationError" }

// Error satisfies the builtin error interface
func (e PGetAllResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPGetAllResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PGetAllResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PGetAllResponseValidationError{}

// Validate checks the field values on PGetAllCommentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PGetAllCommentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PGetAllCommentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PGetAllCommentsResponseMultiError, or nil if none found.
func (m *PGetAllCommentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PGetAllCommentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PGetAllCommentsResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PGetAllCommentsResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PGetAllCommentsResponseValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PGetAllCommentsResponseMultiError(errors)
	}

	return nil
}

// PGetAllCommentsResponseMultiError is an error wrapping multiple validation
// errors returned by PGetAllCommentsResponse.ValidateAll() if the designated
// constraints aren't met.
type PGetAllCommentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PGetAllCommentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PGetAllCommentsResponseMultiError) AllErrors() []error { return m }

// PGetAllCommentsResponseValidationError is the validation error returned by
// PGetAllCommentsResponse.Validate if the designated constraints aren't met.
type PGetAllCommentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PGetAllCommentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PGetAllCommentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PGetAllCommentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PGetAllCommentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PGetAllCommentsResponseValidationError) ErrorName() string {
	return "PGetAllCommentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PGetAllCommentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPGetAllCommentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PGetAllCommentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PGetAllCommentsResponseValidationError{}

// Validate checks the field values on PGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PGetByUUIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PGetByUUIDResponseMultiError, or nil if none found.
func (m *PGetByUUIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PGetByUUIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PGetByUUIDResponseValidationError{
					field:  "Post",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PGetByUUIDResponseValidationError{
					field:  "Post",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PGetByUUIDResponseValidationError{
				field:  "Post",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PGetByUUIDResponseMultiError(errors)
	}

	return nil
}

// PGetByUUIDResponseMultiError is an error wrapping multiple validation errors
// returned by PGetByUUIDResponse.ValidateAll() if the designated constraints
// aren't met.
type PGetByUUIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PGetByUUIDResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PGetByUUIDResponseMultiError) AllErrors() []error { return m }

// PGetByUUIDResponseValidationError is the validation error returned by
// PGetByUUIDResponse.Validate if the designated constraints aren't met.
type PGetByUUIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PGetByUUIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PGetByUUIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PGetByUUIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PGetByUUIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PGetByUUIDResponseValidationError) ErrorName() string {
	return "PGetByUUIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PGetByUUIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPGetByUUIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PGetByUUIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PGetByUUIDResponseValidationError{}

// Validate checks the field values on PCreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PCreateResponseMultiError, or nil if none found.
func (m *PCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	if len(errors) > 0 {
		return PCreateResponseMultiError(errors)
	}

	return nil
}

// PCreateResponseMultiError is an error wrapping multiple validation errors
// returned by PCreateResponse.ValidateAll() if the designated constraints
// aren't met.
type PCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PCreateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PCreateResponseMultiError) AllErrors() []error { return m }

// PCreateResponseValidationError is the validation error returned by
// PCreateResponse.Validate if the designated constraints aren't met.
type PCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PCreateResponseValidationError) ErrorName() string { return "PCreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e PCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PCreateResponseValidationError{}

// Validate checks the field values on DiscussionComment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiscussionComment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiscussionComment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiscussionCommentMultiError, or nil if none found.
func (m *DiscussionComment) ValidateAll() error {
	return m.validate(true)
}

func (m *DiscussionComment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiscussionUuid

	// no validation rules for Body

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscussionCommentValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscussionCommentValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscussionCommentValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for AuthorTag

	if len(errors) > 0 {
		return DiscussionCommentMultiError(errors)
	}

	return nil
}

// DiscussionCommentMultiError is an error wrapping multiple validation errors
// returned by DiscussionComment.ValidateAll() if the designated constraints
// aren't met.
type DiscussionCommentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiscussionCommentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiscussionCommentMultiError) AllErrors() []error { return m }

// DiscussionCommentValidationError is the validation error returned by
// DiscussionComment.Validate if the designated constraints aren't met.
type DiscussionCommentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiscussionCommentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiscussionCommentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiscussionCommentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiscussionCommentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiscussionCommentValidationError) ErrorName() string {
	return "DiscussionCommentValidationError"
}

// Error satisfies the builtin error interface
func (e DiscussionCommentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiscussionComment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiscussionCommentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiscussionCommentValidationError{}

// Validate checks the field values on Discussion with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Discussion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Discussion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiscussionMultiError, or
// nil if none found.
func (m *Discussion) ValidateAll() error {
	return m.validate(true)
}

func (m *Discussion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for Title

	// no validation rules for Body

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiscussionValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiscussionValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiscussionValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AuthorTag

	if len(errors) > 0 {
		return DiscussionMultiError(errors)
	}

	return nil
}

// DiscussionMultiError is an error wrapping multiple validation errors
// returned by Discussion.ValidateAll() if the designated constraints aren't met.
type DiscussionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiscussionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiscussionMultiError) AllErrors() []error { return m }

// DiscussionValidationError is the validation error returned by
// Discussion.Validate if the designated constraints aren't met.
type DiscussionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiscussionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiscussionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiscussionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiscussionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiscussionValidationError) ErrorName() string { return "DiscussionValidationError" }

// Error satisfies the builtin error interface
func (e DiscussionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiscussion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiscussionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiscussionValidationError{}

// Validate checks the field values on DiscussionList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DiscussionList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiscussionList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiscussionListMultiError,
// or nil if none found.
func (m *DiscussionList) ValidateAll() error {
	return m.validate(true)
}

func (m *DiscussionList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDiscussions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiscussionListValidationError{
						field:  fmt.Sprintf("Discussions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiscussionListValidationError{
						field:  fmt.Sprintf("Discussions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiscussionListValidationError{
					field:  fmt.Sprintf("Discussions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DiscussionListMultiError(errors)
	}

	return nil
}

// DiscussionListMultiError is an error wrapping multiple validation errors
// returned by DiscussionList.ValidateAll() if the designated constraints
// aren't met.
type DiscussionListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiscussionListMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiscussionListMultiError) AllErrors() []error { return m }

// DiscussionListValidationError is the validation error returned by
// DiscussionList.Validate if the designated constraints aren't met.
type DiscussionListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiscussionListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiscussionListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiscussionListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiscussionListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiscussionListValidationError) ErrorName() string { return "DiscussionListValidationError" }

// Error satisfies the builtin error interface
func (e DiscussionListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiscussionList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiscussionListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiscussionListValidationError{}

// Validate checks the field values on DGetAllResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DGetAllResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetAllResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetAllResponseMultiError, or nil if none found.
func (m *DGetAllResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetAllResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDiscussions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DGetAllResponseValidationError{
					field:  "Discussions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DGetAllResponseValidationError{
					field:  "Discussions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiscussions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DGetAllResponseValidationError{
				field:  "Discussions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DGetAllResponseMultiError(errors)
	}

	return nil
}

// DGetAllResponseMultiError is an error wrapping multiple validation errors
// returned by DGetAllResponse.ValidateAll() if the designated constraints
// aren't met.
type DGetAllResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetAllResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetAllResponseMultiError) AllErrors() []error { return m }

// DGetAllResponseValidationError is the validation error returned by
// DGetAllResponse.Validate if the designated constraints aren't met.
type DGetAllResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetAllResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetAllResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetAllResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetAllResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetAllResponseValidationError) ErrorName() string { return "DGetAllResponseValidationError" }

// Error satisfies the builtin error interface
func (e DGetAllResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetAllResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetAllResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetAllResponseValidationError{}

// Validate checks the field values on DGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DGetByUUIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetByUUIDResponseMultiError, or nil if none found.
func (m *DGetByUUIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetByUUIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDiscussion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DGetByUUIDResponseValidationError{
					field:  "Discussion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DGetByUUIDResponseValidationError{
					field:  "Discussion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiscussion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DGetByUUIDResponseValidationError{
				field:  "Discussion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DGetByUUIDResponseMultiError(errors)
	}

	return nil
}

// DGetByUUIDResponseMultiError is an error wrapping multiple validation errors
// returned by DGetByUUIDResponse.ValidateAll() if the designated constraints
// aren't met.
type DGetByUUIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetByUUIDResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetByUUIDResponseMultiError) AllErrors() []error { return m }

// DGetByUUIDResponseValidationError is the validation error returned by
// DGetByUUIDResponse.Validate if the designated constraints aren't met.
type DGetByUUIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetByUUIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetByUUIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetByUUIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetByUUIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetByUUIDResponseValidationError) ErrorName() string {
	return "DGetByUUIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DGetByUUIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetByUUIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetByUUIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetByUUIDResponseValidationError{}

// Validate checks the field values on DGetAllWithFilterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DGetAllWithFilterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetAllWithFilterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetAllWithFilterResponseMultiError, or nil if none found.
func (m *DGetAllWithFilterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetAllWithFilterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDiscussions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DGetAllWithFilterResponseValidationError{
					field:  "Discussions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DGetAllWithFilterResponseValidationError{
					field:  "Discussions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiscussions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DGetAllWithFilterResponseValidationError{
				field:  "Discussions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DGetAllWithFilterResponseMultiError(errors)
	}

	return nil
}

// DGetAllWithFilterResponseMultiError is an error wrapping multiple validation
// errors returned by DGetAllWithFilterResponse.ValidateAll() if the
// designated constraints aren't met.
type DGetAllWithFilterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetAllWithFilterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetAllWithFilterResponseMultiError) AllErrors() []error { return m }

// DGetAllWithFilterResponseValidationError is the validation error returned by
// DGetAllWithFilterResponse.Validate if the designated constraints aren't met.
type DGetAllWithFilterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetAllWithFilterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetAllWithFilterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetAllWithFilterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetAllWithFilterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetAllWithFilterResponseValidationError) ErrorName() string {
	return "DGetAllWithFilterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DGetAllWithFilterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetAllWithFilterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetAllWithFilterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetAllWithFilterResponseValidationError{}

// Validate checks the field values on DCreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DCreateResponseMultiError, or nil if none found.
func (m *DCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	if len(errors) > 0 {
		return DCreateResponseMultiError(errors)
	}

	return nil
}

// DCreateResponseMultiError is an error wrapping multiple validation errors
// returned by DCreateResponse.ValidateAll() if the designated constraints
// aren't met.
type DCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DCreateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DCreateResponseMultiError) AllErrors() []error { return m }

// DCreateResponseValidationError is the validation error returned by
// DCreateResponse.Validate if the designated constraints aren't met.
type DCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DCreateResponseValidationError) ErrorName() string { return "DCreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e DCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DCreateResponseValidationError{}

// Validate checks the field values on DGetAllCommentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DGetAllCommentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetAllCommentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetAllCommentsResponseMultiError, or nil if none found.
func (m *DGetAllCommentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetAllCommentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetComments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DGetAllCommentsResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DGetAllCommentsResponseValidationError{
						field:  fmt.Sprintf("Comments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DGetAllCommentsResponseValidationError{
					field:  fmt.Sprintf("Comments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DGetAllCommentsResponseMultiError(errors)
	}

	return nil
}

// DGetAllCommentsResponseMultiError is an error wrapping multiple validation
// errors returned by DGetAllCommentsResponse.ValidateAll() if the designated
// constraints aren't met.
type DGetAllCommentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetAllCommentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetAllCommentsResponseMultiError) AllErrors() []error { return m }

// DGetAllCommentsResponseValidationError is the validation error returned by
// DGetAllCommentsResponse.Validate if the designated constraints aren't met.
type DGetAllCommentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetAllCommentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetAllCommentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetAllCommentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetAllCommentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetAllCommentsResponseValidationError) ErrorName() string {
	return "DGetAllCommentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DGetAllCommentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetAllCommentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetAllCommentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetAllCommentsResponseValidationError{}

// Validate checks the field values on Lesson with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Lesson) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Lesson with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LessonMultiError, or nil if none found.
func (m *Lesson) ValidateAll() error {
	return m.validate(true)
}

func (m *Lesson) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for CourseUuid

	// no validation rules for Title

	// no validation rules for Body

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return LessonMultiError(errors)
	}

	return nil
}

// LessonMultiError is an error wrapping multiple validation errors returned by
// Lesson.ValidateAll() if the designated constraints aren't met.
type LessonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LessonMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LessonMultiError) AllErrors() []error { return m }

// LessonValidationError is the validation error returned by Lesson.Validate if
// the designated constraints aren't met.
type LessonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LessonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LessonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LessonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LessonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LessonValidationError) ErrorName() string { return "LessonValidationError" }

// Error satisfies the builtin error interface
func (e LessonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLesson.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LessonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LessonValidationError{}

// Validate checks the field values on Course with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Course) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Course with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CourseMultiError, or nil if none found.
func (m *Course) ValidateAll() error {
	return m.validate(true)
}

func (m *Course) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for CommunityUuid

	// no validation rules for Title

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetVotes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CourseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CourseValidationError{
					field:  "Votes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVotes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CourseValidationError{
				field:  "Votes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetLessons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CourseValidationError{
						field:  fmt.Sprintf("Lessons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CourseValidationError{
						field:  fmt.Sprintf("Lessons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CourseValidationError{
					field:  fmt.Sprintf("Lessons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CourseMultiError(errors)
	}

	return nil
}

// CourseMultiError is an error wrapping multiple validation errors returned by
// Course.ValidateAll() if the designated constraints aren't met.
type CourseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourseMultiError) AllErrors() []error { return m }

// CourseValidationError is the validation error returned by Course.Validate if
// the designated constraints aren't met.
type CourseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourseValidationError) ErrorName() string { return "CourseValidationError" }

// Error satisfies the builtin error interface
func (e CourseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourseValidationError{}

// Validate checks the field values on CGetAllResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CGetAllResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetAllResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetAllResponseMultiError, or nil if none found.
func (m *CGetAllResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetAllResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCourses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CGetAllResponseValidationError{
						field:  fmt.Sprintf("Courses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CGetAllResponseValidationError{
						field:  fmt.Sprintf("Courses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CGetAllResponseValidationError{
					field:  fmt.Sprintf("Courses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CGetAllResponseMultiError(errors)
	}

	return nil
}

// CGetAllResponseMultiError is an error wrapping multiple validation errors
// returned by CGetAllResponse.ValidateAll() if the designated constraints
// aren't met.
type CGetAllResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetAllResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetAllResponseMultiError) AllErrors() []error { return m }

// CGetAllResponseValidationError is the validation error returned by
// CGetAllResponse.Validate if the designated constraints aren't met.
type CGetAllResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetAllResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetAllResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetAllResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetAllResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetAllResponseValidationError) ErrorName() string { return "CGetAllResponseValidationError" }

// Error satisfies the builtin error interface
func (e CGetAllResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetAllResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetAllResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetAllResponseValidationError{}

// Validate checks the field values on CGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetByUUIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetByUUIDResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetByUUIDResponseMultiError, or nil if none found.
func (m *CGetByUUIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetByUUIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCourse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CGetByUUIDResponseValidationError{
					field:  "Course",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CGetByUUIDResponseValidationError{
					field:  "Course",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCourse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CGetByUUIDResponseValidationError{
				field:  "Course",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CGetByUUIDResponseMultiError(errors)
	}

	return nil
}

// CGetByUUIDResponseMultiError is an error wrapping multiple validation errors
// returned by CGetByUUIDResponse.ValidateAll() if the designated constraints
// aren't met.
type CGetByUUIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetByUUIDResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetByUUIDResponseMultiError) AllErrors() []error { return m }

// CGetByUUIDResponseValidationError is the validation error returned by
// CGetByUUIDResponse.Validate if the designated constraints aren't met.
type CGetByUUIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetByUUIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetByUUIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetByUUIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetByUUIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetByUUIDResponseValidationError) ErrorName() string {
	return "CGetByUUIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CGetByUUIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetByUUIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetByUUIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetByUUIDResponseValidationError{}

// Validate checks the field values on CGetAllWithFilterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetAllWithFilterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetAllWithFilterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetAllWithFilterResponseMultiError, or nil if none found.
func (m *CGetAllWithFilterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetAllWithFilterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCourses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CGetAllWithFilterResponseValidationError{
						field:  fmt.Sprintf("Courses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CGetAllWithFilterResponseValidationError{
						field:  fmt.Sprintf("Courses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CGetAllWithFilterResponseValidationError{
					field:  fmt.Sprintf("Courses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CGetAllWithFilterResponseMultiError(errors)
	}

	return nil
}

// CGetAllWithFilterResponseMultiError is an error wrapping multiple validation
// errors returned by CGetAllWithFilterResponse.ValidateAll() if the
// designated constraints aren't met.
type CGetAllWithFilterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetAllWithFilterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetAllWithFilterResponseMultiError) AllErrors() []error { return m }

// CGetAllWithFilterResponseValidationError is the validation error returned by
// CGetAllWithFilterResponse.Validate if the designated constraints aren't met.
type CGetAllWithFilterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetAllWithFilterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetAllWithFilterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetAllWithFilterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetAllWithFilterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetAllWithFilterResponseValidationError) ErrorName() string {
	return "CGetAllWithFilterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CGetAllWithFilterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetAllWithFilterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetAllWithFilterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetAllWithFilterResponseValidationError{}

// Validate checks the field values on CCreateResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CCreateResponseMultiError, or nil if none found.
func (m *CCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	if len(errors) > 0 {
		return CCreateResponseMultiError(errors)
	}

	return nil
}

// CCreateResponseMultiError is an error wrapping multiple validation errors
// returned by CCreateResponse.ValidateAll() if the designated constraints
// aren't met.
type CCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CCreateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CCreateResponseMultiError) AllErrors() []error { return m }

// CCreateResponseValidationError is the validation error returned by
// CCreateResponse.Validate if the designated constraints aren't met.
type CCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CCreateResponseValidationError) ErrorName() string { return "CCreateResponseValidationError" }

// Error satisfies the builtin error interface
func (e CCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CCreateResponseValidationError{}

// Validate checks the field values on CGetAllLessonsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetAllLessonsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetAllLessonsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetAllLessonsResponseMultiError, or nil if none found.
func (m *CGetAllLessonsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetAllLessonsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLessons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CGetAllLessonsResponseValidationError{
						field:  fmt.Sprintf("Lessons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CGetAllLessonsResponseValidationError{
						field:  fmt.Sprintf("Lessons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CGetAllLessonsResponseValidationError{
					field:  fmt.Sprintf("Lessons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CGetAllLessonsResponseMultiError(errors)
	}

	return nil
}

// CGetAllLessonsResponseMultiError is an error wrapping multiple validation
// errors returned by CGetAllLessonsResponse.ValidateAll() if the designated
// constraints aren't met.
type CGetAllLessonsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetAllLessonsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetAllLessonsResponseMultiError) AllErrors() []error { return m }

// CGetAllLessonsResponseValidationError is the validation error returned by
// CGetAllLessonsResponse.Validate if the designated constraints aren't met.
type CGetAllLessonsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetAllLessonsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetAllLessonsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetAllLessonsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetAllLessonsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetAllLessonsResponseValidationError) ErrorName() string {
	return "CGetAllLessonsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CGetAllLessonsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetAllLessonsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetAllLessonsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetAllLessonsResponseValidationError{}

// Validate checks the field values on CGetByUUIDLessonsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetByUUIDLessonsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetByUUIDLessonsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetByUUIDLessonsResponseMultiError, or nil if none found.
func (m *CGetByUUIDLessonsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetByUUIDLessonsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLesson()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CGetByUUIDLessonsResponseValidationError{
					field:  "Lesson",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CGetByUUIDLessonsResponseValidationError{
					field:  "Lesson",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLesson()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CGetByUUIDLessonsResponseValidationError{
				field:  "Lesson",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CGetByUUIDLessonsResponseMultiError(errors)
	}

	return nil
}

// CGetByUUIDLessonsResponseMultiError is an error wrapping multiple validation
// errors returned by CGetByUUIDLessonsResponse.ValidateAll() if the
// designated constraints aren't met.
type CGetByUUIDLessonsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetByUUIDLessonsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetByUUIDLessonsResponseMultiError) AllErrors() []error { return m }

// CGetByUUIDLessonsResponseValidationError is the validation error returned by
// CGetByUUIDLessonsResponse.Validate if the designated constraints aren't met.
type CGetByUUIDLessonsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetByUUIDLessonsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetByUUIDLessonsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetByUUIDLessonsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetByUUIDLessonsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetByUUIDLessonsResponseValidationError) ErrorName() string {
	return "CGetByUUIDLessonsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CGetByUUIDLessonsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetByUUIDLessonsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetByUUIDLessonsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetByUUIDLessonsResponseValidationError{}

// Validate checks the field values on CountOfPagesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountOfPagesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountOfPagesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountOfPagesResponseMultiError, or nil if none found.
func (m *CountOfPagesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CountOfPagesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CountOfPages

	if len(errors) > 0 {
		return CountOfPagesResponseMultiError(errors)
	}

	return nil
}

// CountOfPagesResponseMultiError is an error wrapping multiple validation
// errors returned by CountOfPagesResponse.ValidateAll() if the designated
// constraints aren't met.
type CountOfPagesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountOfPagesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountOfPagesResponseMultiError) AllErrors() []error { return m }

// CountOfPagesResponseValidationError is the validation error returned by
// CountOfPagesResponse.Validate if the designated constraints aren't met.
type CountOfPagesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountOfPagesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountOfPagesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountOfPagesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountOfPagesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountOfPagesResponseValidationError) ErrorName() string {
	return "CountOfPagesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CountOfPagesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountOfPagesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountOfPagesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountOfPagesResponseValidationError{}

// Validate checks the field values on ReporterObject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReporterObject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReporterObject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReporterObjectMultiError,
// or nil if none found.
func (m *ReporterObject) ValidateAll() error {
	return m.validate(true)
}

func (m *ReporterObject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReporterObjectValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommunity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Community",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Community",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommunity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReporterObjectValidationError{
				field:  "Community",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Post",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Post",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReporterObjectValidationError{
				field:  "Post",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDiscussion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Discussion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Discussion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiscussion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReporterObjectValidationError{
				field:  "Discussion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCourse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Course",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReporterObjectValidationError{
					field:  "Course",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCourse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReporterObjectValidationError{
				field:  "Course",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReporterObjectMultiError(errors)
	}

	return nil
}

// ReporterObjectMultiError is an error wrapping multiple validation errors
// returned by ReporterObject.ValidateAll() if the designated constraints
// aren't met.
type ReporterObjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReporterObjectMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReporterObjectMultiError) AllErrors() []error { return m }

// ReporterObjectValidationError is the validation error returned by
// ReporterObject.Validate if the designated constraints aren't met.
type ReporterObjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReporterObjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReporterObjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReporterObjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReporterObjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReporterObjectValidationError) ErrorName() string { return "ReporterObjectValidationError" }

// Error satisfies the builtin error interface
func (e ReporterObjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReporterObject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReporterObjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReporterObjectValidationError{}

// Validate checks the field values on Report with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Report) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Report with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReportMultiError, or nil if none found.
func (m *Report) ValidateAll() error {
	return m.validate(true)
}

func (m *Report) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CommunityUuid

	// no validation rules for Message

	// no validation rules for AddressedObj

	// no validation rules for TypeReport

	// no validation rules for CreatedAt

	// no validation rules for SenderUuid

	if all {
		switch v := interface{}(m.GetReporterObject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "ReporterObject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "ReporterObject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReporterObject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportValidationError{
				field:  "ReporterObject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportMultiError(errors)
	}

	return nil
}

// ReportMultiError is an error wrapping multiple validation errors returned by
// Report.ValidateAll() if the designated constraints aren't met.
type ReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportMultiError) AllErrors() []error { return m }

// ReportValidationError is the validation error returned by Report.Validate if
// the designated constraints aren't met.
type ReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportValidationError) ErrorName() string { return "ReportValidationError" }

// Error satisfies the builtin error interface
func (e ReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportValidationError{}

// Validate checks the field values on RGetAllResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RGetAllResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RGetAllResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RGetAllResponseMultiError, or nil if none found.
func (m *RGetAllResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RGetAllResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReports() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RGetAllResponseValidationError{
						field:  fmt.Sprintf("Reports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RGetAllResponseValidationError{
						field:  fmt.Sprintf("Reports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RGetAllResponseValidationError{
					field:  fmt.Sprintf("Reports[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RGetAllResponseMultiError(errors)
	}

	return nil
}

// RGetAllResponseMultiError is an error wrapping multiple validation errors
// returned by RGetAllResponse.ValidateAll() if the designated constraints
// aren't met.
type RGetAllResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RGetAllResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RGetAllResponseMultiError) AllErrors() []error { return m }

// RGetAllResponseValidationError is the validation error returned by
// RGetAllResponse.Validate if the designated constraints aren't met.
type RGetAllResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RGetAllResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RGetAllResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RGetAllResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RGetAllResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RGetAllResponseValidationError) ErrorName() string { return "RGetAllResponseValidationError" }

// Error satisfies the builtin error interface
func (e RGetAllResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRGetAllResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RGetAllResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RGetAllResponseValidationError{}

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = LoginRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 32 {
		err := LoginRequestValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

func (m *LoginRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *LoginRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = RegisterRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 6 || l > 32 {
		err := RegisterRequestValidationError{
			field:  "Password",
			reason: "value length must be between 6 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

func (m *RegisterRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *RegisterRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenRequestMultiError, or nil if none found.
func (m *RefreshTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return RefreshTokenRequestMultiError(errors)
	}

	return nil
}

// RefreshTokenRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenRequestMultiError) AllErrors() []error { return m }

// RefreshTokenRequestValidationError is the validation error returned by
// RefreshTokenRequest.Validate if the designated constraints aren't met.
type RefreshTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenRequestValidationError) ErrorName() string {
	return "RefreshTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenRequestValidationError{}

// Validate checks the field values on UGetByTagRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UGetByTagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UGetByTagRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UGetByTagRequestMultiError, or nil if none found.
func (m *UGetByTagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UGetByTagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UGetByTagRequest_UserTag_Pattern.MatchString(m.GetUserTag()) {
		err := UGetByTagRequestValidationError{
			field:  "UserTag",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_\\\\-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UGetByTagRequestMultiError(errors)
	}

	return nil
}

// UGetByTagRequestMultiError is an error wrapping multiple validation errors
// returned by UGetByTagRequest.ValidateAll() if the designated constraints
// aren't met.
type UGetByTagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UGetByTagRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UGetByTagRequestMultiError) AllErrors() []error { return m }

// UGetByTagRequestValidationError is the validation error returned by
// UGetByTagRequest.Validate if the designated constraints aren't met.
type UGetByTagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UGetByTagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UGetByTagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UGetByTagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UGetByTagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UGetByTagRequestValidationError) ErrorName() string { return "UGetByTagRequestValidationError" }

// Error satisfies the builtin error interface
func (e UGetByTagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUGetByTagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UGetByTagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UGetByTagRequestValidationError{}

var _UGetByTagRequest_UserTag_Pattern = regexp.MustCompile("^[a-zA-Z0-9_\\-]+$")

// Validate checks the field values on UUpdateProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UUpdateProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UUpdateProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UUpdateProfileRequestMultiError, or nil if none found.
func (m *UUpdateProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UUpdateProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UUpdateProfileRequest_NewUserTag_Pattern.MatchString(m.GetNewUserTag()) {
		err := UUpdateProfileRequestValidationError{
			field:  "NewUserTag",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_\\\\-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Username

	if utf8.RuneCountInString(m.GetAbout()) > 300 {
		err := UUpdateProfileRequestValidationError{
			field:  "About",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UUpdateProfileRequestMultiError(errors)
	}

	return nil
}

// UUpdateProfileRequestMultiError is an error wrapping multiple validation
// errors returned by UUpdateProfileRequest.ValidateAll() if the designated
// constraints aren't met.
type UUpdateProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UUpdateProfileRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UUpdateProfileRequestMultiError) AllErrors() []error { return m }

// UUpdateProfileRequestValidationError is the validation error returned by
// UUpdateProfileRequest.Validate if the designated constraints aren't met.
type UUpdateProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UUpdateProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UUpdateProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UUpdateProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UUpdateProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UUpdateProfileRequestValidationError) ErrorName() string {
	return "UUpdateProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UUpdateProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUUpdateProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UUpdateProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UUpdateProfileRequestValidationError{}

var _UUpdateProfileRequest_NewUserTag_Pattern = regexp.MustCompile("^[a-zA-Z0-9_\\-]+$")

// Validate checks the field values on UVoteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UVoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UVoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UVoteRequestMultiError, or
// nil if none found.
func (m *UVoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UVoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UVoteRequest_UserTag_Pattern.MatchString(m.GetUserTag()) {
		err := UVoteRequestValidationError{
			field:  "UserTag",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_\\\\-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Vote

	if len(errors) > 0 {
		return UVoteRequestMultiError(errors)
	}

	return nil
}

// UVoteRequestMultiError is an error wrapping multiple validation errors
// returned by UVoteRequest.ValidateAll() if the designated constraints aren't met.
type UVoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UVoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UVoteRequestMultiError) AllErrors() []error { return m }

// UVoteRequestValidationError is the validation error returned by
// UVoteRequest.Validate if the designated constraints aren't met.
type UVoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UVoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UVoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UVoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UVoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UVoteRequestValidationError) ErrorName() string { return "UVoteRequestValidationError" }

// Error satisfies the builtin error interface
func (e UVoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUVoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UVoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UVoteRequestValidationError{}

var _UVoteRequest_UserTag_Pattern = regexp.MustCompile("^[a-zA-Z0-9_\\-]+$")

// Validate checks the field values on UAddToCommunityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UAddToCommunityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UAddToCommunityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UAddToCommunityRequestMultiError, or nil if none found.
func (m *UAddToCommunityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UAddToCommunityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = UAddToCommunityRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UAddToCommunityRequestMultiError(errors)
	}

	return nil
}

func (m *UAddToCommunityRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UAddToCommunityRequestMultiError is an error wrapping multiple validation
// errors returned by UAddToCommunityRequest.ValidateAll() if the designated
// constraints aren't met.
type UAddToCommunityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UAddToCommunityRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UAddToCommunityRequestMultiError) AllErrors() []error { return m }

// UAddToCommunityRequestValidationError is the validation error returned by
// UAddToCommunityRequest.Validate if the designated constraints aren't met.
type UAddToCommunityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UAddToCommunityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UAddToCommunityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UAddToCommunityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UAddToCommunityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UAddToCommunityRequestValidationError) ErrorName() string {
	return "UAddToCommunityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UAddToCommunityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUAddToCommunityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UAddToCommunityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UAddToCommunityRequestValidationError{}

// Validate checks the field values on ULeaveFromCommunityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ULeaveFromCommunityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ULeaveFromCommunityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ULeaveFromCommunityRequestMultiError, or nil if none found.
func (m *ULeaveFromCommunityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ULeaveFromCommunityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = ULeaveFromCommunityRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ULeaveFromCommunityRequestMultiError(errors)
	}

	return nil
}

func (m *ULeaveFromCommunityRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ULeaveFromCommunityRequestMultiError is an error wrapping multiple
// validation errors returned by ULeaveFromCommunityRequest.ValidateAll() if
// the designated constraints aren't met.
type ULeaveFromCommunityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ULeaveFromCommunityRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ULeaveFromCommunityRequestMultiError) AllErrors() []error { return m }

// ULeaveFromCommunityRequestValidationError is the validation error returned
// by ULeaveFromCommunityRequest.Validate if the designated constraints aren't met.
type ULeaveFromCommunityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ULeaveFromCommunityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ULeaveFromCommunityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ULeaveFromCommunityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ULeaveFromCommunityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ULeaveFromCommunityRequestValidationError) ErrorName() string {
	return "ULeaveFromCommunityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ULeaveFromCommunityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sULeaveFromCommunityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ULeaveFromCommunityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ULeaveFromCommunityRequestValidationError{}

// Validate checks the field values on UChangeRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UChangeRoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UChangeRoleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UChangeRoleRequestMultiError, or nil if none found.
func (m *UChangeRoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UChangeRoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UChangeRoleRequest_UserTag_Pattern.MatchString(m.GetUserTag()) {
		err := UChangeRoleRequestValidationError{
			field:  "UserTag",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_\\\\-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Role

	if len(errors) > 0 {
		return UChangeRoleRequestMultiError(errors)
	}

	return nil
}

// UChangeRoleRequestMultiError is an error wrapping multiple validation errors
// returned by UChangeRoleRequest.ValidateAll() if the designated constraints
// aren't met.
type UChangeRoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UChangeRoleRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UChangeRoleRequestMultiError) AllErrors() []error { return m }

// UChangeRoleRequestValidationError is the validation error returned by
// UChangeRoleRequest.Validate if the designated constraints aren't met.
type UChangeRoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UChangeRoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UChangeRoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UChangeRoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UChangeRoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UChangeRoleRequestValidationError) ErrorName() string {
	return "UChangeRoleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UChangeRoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUChangeRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UChangeRoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UChangeRoleRequestValidationError{}

var _UChangeRoleRequest_UserTag_Pattern = regexp.MustCompile("^[a-zA-Z0-9_\\-]+$")

// Validate checks the field values on CmGetAllRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CmGetAllRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmGetAllRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmGetAllRequestMultiError, or nil if none found.
func (m *CmGetAllRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmGetAllRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for SizeOfPage

	if len(errors) > 0 {
		return CmGetAllRequestMultiError(errors)
	}

	return nil
}

// CmGetAllRequestMultiError is an error wrapping multiple validation errors
// returned by CmGetAllRequest.ValidateAll() if the designated constraints
// aren't met.
type CmGetAllRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmGetAllRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmGetAllRequestMultiError) AllErrors() []error { return m }

// CmGetAllRequestValidationError is the validation error returned by
// CmGetAllRequest.Validate if the designated constraints aren't met.
type CmGetAllRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmGetAllRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmGetAllRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmGetAllRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmGetAllRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmGetAllRequestValidationError) ErrorName() string { return "CmGetAllRequestValidationError" }

// Error satisfies the builtin error interface
func (e CmGetAllRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmGetAllRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmGetAllRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmGetAllRequestValidationError{}

// Validate checks the field values on CmGetByUUIDRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CmGetByUUIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmGetByUUIDRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmGetByUUIDRequestMultiError, or nil if none found.
func (m *CmGetByUUIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmGetByUUIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CmGetByUUIDRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CmGetByUUIDRequestMultiError(errors)
	}

	return nil
}

func (m *CmGetByUUIDRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CmGetByUUIDRequestMultiError is an error wrapping multiple validation errors
// returned by CmGetByUUIDRequest.ValidateAll() if the designated constraints
// aren't met.
type CmGetByUUIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmGetByUUIDRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmGetByUUIDRequestMultiError) AllErrors() []error { return m }

// CmGetByUUIDRequestValidationError is the validation error returned by
// CmGetByUUIDRequest.Validate if the designated constraints aren't met.
type CmGetByUUIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmGetByUUIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmGetByUUIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmGetByUUIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmGetByUUIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmGetByUUIDRequestValidationError) ErrorName() string {
	return "CmGetByUUIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CmGetByUUIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmGetByUUIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmGetByUUIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmGetByUUIDRequestValidationError{}

// Validate checks the field values on Sort with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Sort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sort with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SortMultiError, or nil if none found.
func (m *Sort) ValidateAll() error {
	return m.validate(true)
}

func (m *Sort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Field

	// no validation rules for IsDescending

	if len(errors) > 0 {
		return SortMultiError(errors)
	}

	return nil
}

// SortMultiError is an error wrapping multiple validation errors returned by
// Sort.ValidateAll() if the designated constraints aren't met.
type SortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SortMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SortMultiError) AllErrors() []error { return m }

// SortValidationError is the validation error returned by Sort.Validate if the
// designated constraints aren't met.
type SortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SortValidationError) ErrorName() string { return "SortValidationError" }

// Error satisfies the builtin error interface
func (e SortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SortValidationError{}

// Validate checks the field values on CmGetAllWithFilterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CmGetAllWithFilterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmGetAllWithFilterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmGetAllWithFilterRequestMultiError, or nil if none found.
func (m *CmGetAllWithFilterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmGetAllWithFilterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for LowPrice

	// no validation rules for HighPrice

	// no validation rules for Page

	// no validation rules for SizeOfPage

	if all {
		switch v := interface{}(m.GetSort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CmGetAllWithFilterRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CmGetAllWithFilterRequestValidationError{
					field:  "Sort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CmGetAllWithFilterRequestValidationError{
				field:  "Sort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CmGetAllWithFilterRequestMultiError(errors)
	}

	return nil
}

// CmGetAllWithFilterRequestMultiError is an error wrapping multiple validation
// errors returned by CmGetAllWithFilterRequest.ValidateAll() if the
// designated constraints aren't met.
type CmGetAllWithFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmGetAllWithFilterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmGetAllWithFilterRequestMultiError) AllErrors() []error { return m }

// CmGetAllWithFilterRequestValidationError is the validation error returned by
// CmGetAllWithFilterRequest.Validate if the designated constraints aren't met.
type CmGetAllWithFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmGetAllWithFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmGetAllWithFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmGetAllWithFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmGetAllWithFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmGetAllWithFilterRequestValidationError) ErrorName() string {
	return "CmGetAllWithFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CmGetAllWithFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmGetAllWithFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmGetAllWithFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmGetAllWithFilterRequestValidationError{}

// Validate checks the field values on CmCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CmCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmCreateRequestMultiError, or nil if none found.
func (m *CmCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CmCreateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 300 {
		err := CmCreateRequestValidationError{
			field:  "Description",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Price

	if len(errors) > 0 {
		return CmCreateRequestMultiError(errors)
	}

	return nil
}

// CmCreateRequestMultiError is an error wrapping multiple validation errors
// returned by CmCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type CmCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmCreateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmCreateRequestMultiError) AllErrors() []error { return m }

// CmCreateRequestValidationError is the validation error returned by
// CmCreateRequest.Validate if the designated constraints aren't met.
type CmCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmCreateRequestValidationError) ErrorName() string { return "CmCreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e CmCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmCreateRequestValidationError{}

// Validate checks the field values on CmDeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CmDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmDeleteRequestMultiError, or nil if none found.
func (m *CmDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CmDeleteRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CmDeleteRequestMultiError(errors)
	}

	return nil
}

func (m *CmDeleteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CmDeleteRequestMultiError is an error wrapping multiple validation errors
// returned by CmDeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type CmDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmDeleteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmDeleteRequestMultiError) AllErrors() []error { return m }

// CmDeleteRequestValidationError is the validation error returned by
// CmDeleteRequest.Validate if the designated constraints aren't met.
type CmDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmDeleteRequestValidationError) ErrorName() string { return "CmDeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e CmDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmDeleteRequestValidationError{}

// Validate checks the field values on CmUpdateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CmUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmUpdateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CmUpdateRequestMultiError, or nil if none found.
func (m *CmUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CmUpdateRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CmUpdateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 300 {
		err := CmUpdateRequestValidationError{
			field:  "Description",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Price

	if len(errors) > 0 {
		return CmUpdateRequestMultiError(errors)
	}

	return nil
}

func (m *CmUpdateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CmUpdateRequestMultiError is an error wrapping multiple validation errors
// returned by CmUpdateRequest.ValidateAll() if the designated constraints
// aren't met.
type CmUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmUpdateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmUpdateRequestMultiError) AllErrors() []error { return m }

// CmUpdateRequestValidationError is the validation error returned by
// CmUpdateRequest.Validate if the designated constraints aren't met.
type CmUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmUpdateRequestValidationError) ErrorName() string { return "CmUpdateRequestValidationError" }

// Error satisfies the builtin error interface
func (e CmUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmUpdateRequestValidationError{}

// Validate checks the field values on CmVoteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CmVoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmVoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CmVoteRequestMultiError, or
// nil if none found.
func (m *CmVoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmVoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CmVoteRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Vote

	if len(errors) > 0 {
		return CmVoteRequestMultiError(errors)
	}

	return nil
}

func (m *CmVoteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CmVoteRequestMultiError is an error wrapping multiple validation errors
// returned by CmVoteRequest.ValidateAll() if the designated constraints
// aren't met.
type CmVoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmVoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmVoteRequestMultiError) AllErrors() []error { return m }

// CmVoteRequestValidationError is the validation error returned by
// CmVoteRequest.Validate if the designated constraints aren't met.
type CmVoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmVoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmVoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmVoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmVoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmVoteRequestValidationError) ErrorName() string { return "CmVoteRequestValidationError" }

// Error satisfies the builtin error interface
func (e CmVoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmVoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmVoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmVoteRequestValidationError{}

// Validate checks the field values on CmBanRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CmBanRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CmBanRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CmBanRequestMultiError, or
// nil if none found.
func (m *CmBanRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CmBanRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CmBanRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CmBanRequestMultiError(errors)
	}

	return nil
}

func (m *CmBanRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CmBanRequestMultiError is an error wrapping multiple validation errors
// returned by CmBanRequest.ValidateAll() if the designated constraints aren't met.
type CmBanRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CmBanRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CmBanRequestMultiError) AllErrors() []error { return m }

// CmBanRequestValidationError is the validation error returned by
// CmBanRequest.Validate if the designated constraints aren't met.
type CmBanRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CmBanRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CmBanRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CmBanRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CmBanRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CmBanRequestValidationError) ErrorName() string { return "CmBanRequestValidationError" }

// Error satisfies the builtin error interface
func (e CmBanRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCmBanRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CmBanRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CmBanRequestValidationError{}

// Validate checks the field values on PGetAllRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PGetAllRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PGetAllRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PGetAllRequestMultiError,
// or nil if none found.
func (m *PGetAllRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PGetAllRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = PGetAllRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for SizeOfPage

	if len(errors) > 0 {
		return PGetAllRequestMultiError(errors)
	}

	return nil
}

func (m *PGetAllRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PGetAllRequestMultiError is an error wrapping multiple validation errors
// returned by PGetAllRequest.ValidateAll() if the designated constraints
// aren't met.
type PGetAllRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PGetAllRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PGetAllRequestMultiError) AllErrors() []error { return m }

// PGetAllRequestValidationError is the validation error returned by
// PGetAllRequest.Validate if the designated constraints aren't met.
type PGetAllRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PGetAllRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PGetAllRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PGetAllRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PGetAllRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PGetAllRequestValidationError) ErrorName() string { return "PGetAllRequestValidationError" }

// Error satisfies the builtin error interface
func (e PGetAllRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPGetAllRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PGetAllRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PGetAllRequestValidationError{}

// Validate checks the field values on PGetByUUIDRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PGetByUUIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PGetByUUIDRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PGetByUUIDRequestMultiError, or nil if none found.
func (m *PGetByUUIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PGetByUUIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetPostUuid()); err != nil {
		err = PGetByUUIDRequestValidationError{
			field:  "PostUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PGetByUUIDRequestMultiError(errors)
	}

	return nil
}

func (m *PGetByUUIDRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PGetByUUIDRequestMultiError is an error wrapping multiple validation errors
// returned by PGetByUUIDRequest.ValidateAll() if the designated constraints
// aren't met.
type PGetByUUIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PGetByUUIDRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PGetByUUIDRequestMultiError) AllErrors() []error { return m }

// PGetByUUIDRequestValidationError is the validation error returned by
// PGetByUUIDRequest.Validate if the designated constraints aren't met.
type PGetByUUIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PGetByUUIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PGetByUUIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PGetByUUIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PGetByUUIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PGetByUUIDRequestValidationError) ErrorName() string {
	return "PGetByUUIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PGetByUUIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPGetByUUIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PGetByUUIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PGetByUUIDRequestValidationError{}

// Validate checks the field values on PostData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PostData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PostDataMultiError, or nil
// if none found.
func (m *PostData) ValidateAll() error {
	return m.validate(true)
}

func (m *PostData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for MimeType

	if len(errors) > 0 {
		return PostDataMultiError(errors)
	}

	return nil
}

// PostDataMultiError is an error wrapping multiple validation errors returned
// by PostData.ValidateAll() if the designated constraints aren't met.
type PostDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostDataMultiError) AllErrors() []error { return m }

// PostDataValidationError is the validation error returned by
// PostData.Validate if the designated constraints aren't met.
type PostDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostDataValidationError) ErrorName() string { return "PostDataValidationError" }

// Error satisfies the builtin error interface
func (e PostDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostDataValidationError{}

// Validate checks the field values on PCreateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PCreateRequestMultiError,
// or nil if none found.
func (m *PCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = PCreateRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := PCreateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Body

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PCreateRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PCreateRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PCreateRequestValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PCreateRequestMultiError(errors)
	}

	return nil
}

func (m *PCreateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PCreateRequestMultiError is an error wrapping multiple validation errors
// returned by PCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type PCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PCreateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PCreateRequestMultiError) AllErrors() []error { return m }

// PCreateRequestValidationError is the validation error returned by
// PCreateRequest.Validate if the designated constraints aren't met.
type PCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PCreateRequestValidationError) ErrorName() string { return "PCreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e PCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PCreateRequestValidationError{}

// Validate checks the field values on PDeleteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PDeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PDeleteRequestMultiError,
// or nil if none found.
func (m *PDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetPostUuid()); err != nil {
		err = PDeleteRequestValidationError{
			field:  "PostUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PDeleteRequestMultiError(errors)
	}

	return nil
}

func (m *PDeleteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PDeleteRequestMultiError is an error wrapping multiple validation errors
// returned by PDeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type PDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PDeleteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PDeleteRequestMultiError) AllErrors() []error { return m }

// PDeleteRequestValidationError is the validation error returned by
// PDeleteRequest.Validate if the designated constraints aren't met.
type PDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PDeleteRequestValidationError) ErrorName() string { return "PDeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e PDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PDeleteRequestValidationError{}

// Validate checks the field values on PUpdateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PUpdateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PUpdateRequestMultiError,
// or nil if none found.
func (m *PUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetPostUuid()); err != nil {
		err = PUpdateRequestValidationError{
			field:  "PostUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := PUpdateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PUpdateRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PUpdateRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PUpdateRequestValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Body

	if len(errors) > 0 {
		return PUpdateRequestMultiError(errors)
	}

	return nil
}

func (m *PUpdateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PUpdateRequestMultiError is an error wrapping multiple validation errors
// returned by PUpdateRequest.ValidateAll() if the designated constraints
// aren't met.
type PUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PUpdateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PUpdateRequestMultiError) AllErrors() []error { return m }

// PUpdateRequestValidationError is the validation error returned by
// PUpdateRequest.Validate if the designated constraints aren't met.
type PUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PUpdateRequestValidationError) ErrorName() string { return "PUpdateRequestValidationError" }

// Error satisfies the builtin error interface
func (e PUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PUpdateRequestValidationError{}

// Validate checks the field values on PGetAllCommentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PGetAllCommentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PGetAllCommentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PGetAllCommentsRequestMultiError, or nil if none found.
func (m *PGetAllCommentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PGetAllCommentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetPostUuid()); err != nil {
		err = PGetAllCommentsRequestValidationError{
			field:  "PostUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if len(errors) > 0 {
		return PGetAllCommentsRequestMultiError(errors)
	}

	return nil
}

func (m *PGetAllCommentsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PGetAllCommentsRequestMultiError is an error wrapping multiple validation
// errors returned by PGetAllCommentsRequest.ValidateAll() if the designated
// constraints aren't met.
type PGetAllCommentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PGetAllCommentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PGetAllCommentsRequestMultiError) AllErrors() []error { return m }

// PGetAllCommentsRequestValidationError is the validation error returned by
// PGetAllCommentsRequest.Validate if the designated constraints aren't met.
type PGetAllCommentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PGetAllCommentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PGetAllCommentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PGetAllCommentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PGetAllCommentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PGetAllCommentsRequestValidationError) ErrorName() string {
	return "PGetAllCommentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PGetAllCommentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPGetAllCommentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PGetAllCommentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PGetAllCommentsRequestValidationError{}

// Validate checks the field values on PCreateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PCreateCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PCreateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PCreateCommentRequestMultiError, or nil if none found.
func (m *PCreateCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PCreateCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetPostUuid()); err != nil {
		err = PCreateCommentRequestValidationError{
			field:  "PostUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBody()) > 500 {
		err := PCreateCommentRequestValidationError{
			field:  "Body",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PCreateCommentRequestMultiError(errors)
	}

	return nil
}

func (m *PCreateCommentRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PCreateCommentRequestMultiError is an error wrapping multiple validation
// errors returned by PCreateCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type PCreateCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PCreateCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PCreateCommentRequestMultiError) AllErrors() []error { return m }

// PCreateCommentRequestValidationError is the validation error returned by
// PCreateCommentRequest.Validate if the designated constraints aren't met.
type PCreateCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PCreateCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PCreateCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PCreateCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PCreateCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PCreateCommentRequestValidationError) ErrorName() string {
	return "PCreateCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PCreateCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPCreateCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PCreateCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PCreateCommentRequestValidationError{}

// Validate checks the field values on PDeleteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PDeleteCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PDeleteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PDeleteCommentRequestMultiError, or nil if none found.
func (m *PDeleteCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PDeleteCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommentId

	if len(errors) > 0 {
		return PDeleteCommentRequestMultiError(errors)
	}

	return nil
}

// PDeleteCommentRequestMultiError is an error wrapping multiple validation
// errors returned by PDeleteCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type PDeleteCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PDeleteCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PDeleteCommentRequestMultiError) AllErrors() []error { return m }

// PDeleteCommentRequestValidationError is the validation error returned by
// PDeleteCommentRequest.Validate if the designated constraints aren't met.
type PDeleteCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PDeleteCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PDeleteCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PDeleteCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PDeleteCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PDeleteCommentRequestValidationError) ErrorName() string {
	return "PDeleteCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PDeleteCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPDeleteCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PDeleteCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PDeleteCommentRequestValidationError{}

// Validate checks the field values on PUpdateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PUpdateCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PUpdateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PUpdateCommentRequestMultiError, or nil if none found.
func (m *PUpdateCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PUpdateCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommentId

	if utf8.RuneCountInString(m.GetBody()) > 500 {
		err := PUpdateCommentRequestValidationError{
			field:  "Body",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PUpdateCommentRequestMultiError(errors)
	}

	return nil
}

// PUpdateCommentRequestMultiError is an error wrapping multiple validation
// errors returned by PUpdateCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type PUpdateCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PUpdateCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PUpdateCommentRequestMultiError) AllErrors() []error { return m }

// PUpdateCommentRequestValidationError is the validation error returned by
// PUpdateCommentRequest.Validate if the designated constraints aren't met.
type PUpdateCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PUpdateCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PUpdateCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PUpdateCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PUpdateCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PUpdateCommentRequestValidationError) ErrorName() string {
	return "PUpdateCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PUpdateCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPUpdateCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PUpdateCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PUpdateCommentRequestValidationError{}

// Validate checks the field values on PVoteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PVoteCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PVoteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PVoteCommentRequestMultiError, or nil if none found.
func (m *PVoteCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PVoteCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommentId

	// no validation rules for Vote

	if len(errors) > 0 {
		return PVoteCommentRequestMultiError(errors)
	}

	return nil
}

// PVoteCommentRequestMultiError is an error wrapping multiple validation
// errors returned by PVoteCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type PVoteCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PVoteCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PVoteCommentRequestMultiError) AllErrors() []error { return m }

// PVoteCommentRequestValidationError is the validation error returned by
// PVoteCommentRequest.Validate if the designated constraints aren't met.
type PVoteCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PVoteCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PVoteCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PVoteCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PVoteCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PVoteCommentRequestValidationError) ErrorName() string {
	return "PVoteCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PVoteCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPVoteCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PVoteCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PVoteCommentRequestValidationError{}

// Validate checks the field values on PVoteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PVoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PVoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PVoteRequestMultiError, or
// nil if none found.
func (m *PVoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PVoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetPostUuid()); err != nil {
		err = PVoteRequestValidationError{
			field:  "PostUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Vote

	if len(errors) > 0 {
		return PVoteRequestMultiError(errors)
	}

	return nil
}

func (m *PVoteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PVoteRequestMultiError is an error wrapping multiple validation errors
// returned by PVoteRequest.ValidateAll() if the designated constraints aren't met.
type PVoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PVoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PVoteRequestMultiError) AllErrors() []error { return m }

// PVoteRequestValidationError is the validation error returned by
// PVoteRequest.Validate if the designated constraints aren't met.
type PVoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PVoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PVoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PVoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PVoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PVoteRequestValidationError) ErrorName() string { return "PVoteRequestValidationError" }

// Error satisfies the builtin error interface
func (e PVoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPVoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PVoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PVoteRequestValidationError{}

// Validate checks the field values on DGetAllRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DGetAllRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetAllRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DGetAllRequestMultiError,
// or nil if none found.
func (m *DGetAllRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetAllRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = DGetAllRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for SizeOfPage

	if len(errors) > 0 {
		return DGetAllRequestMultiError(errors)
	}

	return nil
}

func (m *DGetAllRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DGetAllRequestMultiError is an error wrapping multiple validation errors
// returned by DGetAllRequest.ValidateAll() if the designated constraints
// aren't met.
type DGetAllRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetAllRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetAllRequestMultiError) AllErrors() []error { return m }

// DGetAllRequestValidationError is the validation error returned by
// DGetAllRequest.Validate if the designated constraints aren't met.
type DGetAllRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetAllRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetAllRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetAllRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetAllRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetAllRequestValidationError) ErrorName() string { return "DGetAllRequestValidationError" }

// Error satisfies the builtin error interface
func (e DGetAllRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetAllRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetAllRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetAllRequestValidationError{}

// Validate checks the field values on DGetByUUIDRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DGetByUUIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetByUUIDRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetByUUIDRequestMultiError, or nil if none found.
func (m *DGetByUUIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetByUUIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetDiscussionUuid()); err != nil {
		err = DGetByUUIDRequestValidationError{
			field:  "DiscussionUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return DGetByUUIDRequestMultiError(errors)
	}

	return nil
}

func (m *DGetByUUIDRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DGetByUUIDRequestMultiError is an error wrapping multiple validation errors
// returned by DGetByUUIDRequest.ValidateAll() if the designated constraints
// aren't met.
type DGetByUUIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetByUUIDRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetByUUIDRequestMultiError) AllErrors() []error { return m }

// DGetByUUIDRequestValidationError is the validation error returned by
// DGetByUUIDRequest.Validate if the designated constraints aren't met.
type DGetByUUIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetByUUIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetByUUIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetByUUIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetByUUIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetByUUIDRequestValidationError) ErrorName() string {
	return "DGetByUUIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DGetByUUIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetByUUIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetByUUIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetByUUIDRequestValidationError{}

// Validate checks the field values on DGetAllWithFilterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DGetAllWithFilterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetAllWithFilterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetAllWithFilterRequestMultiError, or nil if none found.
func (m *DGetAllWithFilterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetAllWithFilterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := DGetAllWithFilterRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for SizeOfPage

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = DGetAllWithFilterRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DGetAllWithFilterRequestMultiError(errors)
	}

	return nil
}

func (m *DGetAllWithFilterRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DGetAllWithFilterRequestMultiError is an error wrapping multiple validation
// errors returned by DGetAllWithFilterRequest.ValidateAll() if the designated
// constraints aren't met.
type DGetAllWithFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetAllWithFilterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetAllWithFilterRequestMultiError) AllErrors() []error { return m }

// DGetAllWithFilterRequestValidationError is the validation error returned by
// DGetAllWithFilterRequest.Validate if the designated constraints aren't met.
type DGetAllWithFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetAllWithFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetAllWithFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetAllWithFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetAllWithFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetAllWithFilterRequestValidationError) ErrorName() string {
	return "DGetAllWithFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DGetAllWithFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetAllWithFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetAllWithFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetAllWithFilterRequestValidationError{}

// Validate checks the field values on DCreateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DCreateRequestMultiError,
// or nil if none found.
func (m *DCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = DCreateRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := DCreateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBody()) > 500 {
		err := DCreateRequestValidationError{
			field:  "Body",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DCreateRequestMultiError(errors)
	}

	return nil
}

func (m *DCreateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DCreateRequestMultiError is an error wrapping multiple validation errors
// returned by DCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type DCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DCreateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DCreateRequestMultiError) AllErrors() []error { return m }

// DCreateRequestValidationError is the validation error returned by
// DCreateRequest.Validate if the designated constraints aren't met.
type DCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DCreateRequestValidationError) ErrorName() string { return "DCreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e DCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DCreateRequestValidationError{}

// Validate checks the field values on DDeleteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DDeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DDeleteRequestMultiError,
// or nil if none found.
func (m *DDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetDiscussionUuid()); err != nil {
		err = DDeleteRequestValidationError{
			field:  "DiscussionUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DDeleteRequestMultiError(errors)
	}

	return nil
}

func (m *DDeleteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DDeleteRequestMultiError is an error wrapping multiple validation errors
// returned by DDeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type DDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DDeleteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DDeleteRequestMultiError) AllErrors() []error { return m }

// DDeleteRequestValidationError is the validation error returned by
// DDeleteRequest.Validate if the designated constraints aren't met.
type DDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DDeleteRequestValidationError) ErrorName() string { return "DDeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e DDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DDeleteRequestValidationError{}

// Validate checks the field values on DUpdateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DUpdateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DUpdateRequestMultiError,
// or nil if none found.
func (m *DUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetDiscussionUuid()); err != nil {
		err = DUpdateRequestValidationError{
			field:  "DiscussionUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := DUpdateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBody()) > 500 {
		err := DUpdateRequestValidationError{
			field:  "Body",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DUpdateRequestMultiError(errors)
	}

	return nil
}

func (m *DUpdateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DUpdateRequestMultiError is an error wrapping multiple validation errors
// returned by DUpdateRequest.ValidateAll() if the designated constraints
// aren't met.
type DUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DUpdateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DUpdateRequestMultiError) AllErrors() []error { return m }

// DUpdateRequestValidationError is the validation error returned by
// DUpdateRequest.Validate if the designated constraints aren't met.
type DUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DUpdateRequestValidationError) ErrorName() string { return "DUpdateRequestValidationError" }

// Error satisfies the builtin error interface
func (e DUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DUpdateRequestValidationError{}

// Validate checks the field values on DGetAllCommentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DGetAllCommentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DGetAllCommentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DGetAllCommentsRequestMultiError, or nil if none found.
func (m *DGetAllCommentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DGetAllCommentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetDiscussionUuid()); err != nil {
		err = DGetAllCommentsRequestValidationError{
			field:  "DiscussionUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for SizeOfPage

	if len(errors) > 0 {
		return DGetAllCommentsRequestMultiError(errors)
	}

	return nil
}

func (m *DGetAllCommentsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DGetAllCommentsRequestMultiError is an error wrapping multiple validation
// errors returned by DGetAllCommentsRequest.ValidateAll() if the designated
// constraints aren't met.
type DGetAllCommentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DGetAllCommentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DGetAllCommentsRequestMultiError) AllErrors() []error { return m }

// DGetAllCommentsRequestValidationError is the validation error returned by
// DGetAllCommentsRequest.Validate if the designated constraints aren't met.
type DGetAllCommentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DGetAllCommentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DGetAllCommentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DGetAllCommentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DGetAllCommentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DGetAllCommentsRequestValidationError) ErrorName() string {
	return "DGetAllCommentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DGetAllCommentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDGetAllCommentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DGetAllCommentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DGetAllCommentsRequestValidationError{}

// Validate checks the field values on DCreateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DCreateCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DCreateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DCreateCommentRequestMultiError, or nil if none found.
func (m *DCreateCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DCreateCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetDiscussionUuid()); err != nil {
		err = DCreateCommentRequestValidationError{
			field:  "DiscussionUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBody()) > 500 {
		err := DCreateCommentRequestValidationError{
			field:  "Body",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DCreateCommentRequestMultiError(errors)
	}

	return nil
}

func (m *DCreateCommentRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DCreateCommentRequestMultiError is an error wrapping multiple validation
// errors returned by DCreateCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type DCreateCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DCreateCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DCreateCommentRequestMultiError) AllErrors() []error { return m }

// DCreateCommentRequestValidationError is the validation error returned by
// DCreateCommentRequest.Validate if the designated constraints aren't met.
type DCreateCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DCreateCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DCreateCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DCreateCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DCreateCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DCreateCommentRequestValidationError) ErrorName() string {
	return "DCreateCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DCreateCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDCreateCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DCreateCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DCreateCommentRequestValidationError{}

// Validate checks the field values on DDeleteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DDeleteCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DDeleteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DDeleteCommentRequestMultiError, or nil if none found.
func (m *DDeleteCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DDeleteCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommentId

	if len(errors) > 0 {
		return DDeleteCommentRequestMultiError(errors)
	}

	return nil
}

// DDeleteCommentRequestMultiError is an error wrapping multiple validation
// errors returned by DDeleteCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type DDeleteCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DDeleteCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DDeleteCommentRequestMultiError) AllErrors() []error { return m }

// DDeleteCommentRequestValidationError is the validation error returned by
// DDeleteCommentRequest.Validate if the designated constraints aren't met.
type DDeleteCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DDeleteCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DDeleteCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DDeleteCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DDeleteCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DDeleteCommentRequestValidationError) ErrorName() string {
	return "DDeleteCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DDeleteCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDDeleteCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DDeleteCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DDeleteCommentRequestValidationError{}

// Validate checks the field values on DUpdateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DUpdateCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DUpdateCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DUpdateCommentRequestMultiError, or nil if none found.
func (m *DUpdateCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DUpdateCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommentId

	if utf8.RuneCountInString(m.GetBody()) > 500 {
		err := DUpdateCommentRequestValidationError{
			field:  "Body",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DUpdateCommentRequestMultiError(errors)
	}

	return nil
}

// DUpdateCommentRequestMultiError is an error wrapping multiple validation
// errors returned by DUpdateCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type DUpdateCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DUpdateCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DUpdateCommentRequestMultiError) AllErrors() []error { return m }

// DUpdateCommentRequestValidationError is the validation error returned by
// DUpdateCommentRequest.Validate if the designated constraints aren't met.
type DUpdateCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DUpdateCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DUpdateCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DUpdateCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DUpdateCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DUpdateCommentRequestValidationError) ErrorName() string {
	return "DUpdateCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DUpdateCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDUpdateCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DUpdateCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DUpdateCommentRequestValidationError{}

// Validate checks the field values on DVoteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DVoteCommentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DVoteCommentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DVoteCommentRequestMultiError, or nil if none found.
func (m *DVoteCommentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DVoteCommentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetDiscussionUuid()); err != nil {
		err = DVoteCommentRequestValidationError{
			field:  "DiscussionUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CommentId

	if len(errors) > 0 {
		return DVoteCommentRequestMultiError(errors)
	}

	return nil
}

func (m *DVoteCommentRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DVoteCommentRequestMultiError is an error wrapping multiple validation
// errors returned by DVoteCommentRequest.ValidateAll() if the designated
// constraints aren't met.
type DVoteCommentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DVoteCommentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DVoteCommentRequestMultiError) AllErrors() []error { return m }

// DVoteCommentRequestValidationError is the validation error returned by
// DVoteCommentRequest.Validate if the designated constraints aren't met.
type DVoteCommentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DVoteCommentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DVoteCommentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DVoteCommentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DVoteCommentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DVoteCommentRequestValidationError) ErrorName() string {
	return "DVoteCommentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DVoteCommentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDVoteCommentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DVoteCommentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DVoteCommentRequestValidationError{}

// Validate checks the field values on CGetAllRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CGetAllRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetAllRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CGetAllRequestMultiError,
// or nil if none found.
func (m *CGetAllRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetAllRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CGetAllRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if len(errors) > 0 {
		return CGetAllRequestMultiError(errors)
	}

	return nil
}

func (m *CGetAllRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CGetAllRequestMultiError is an error wrapping multiple validation errors
// returned by CGetAllRequest.ValidateAll() if the designated constraints
// aren't met.
type CGetAllRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetAllRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetAllRequestMultiError) AllErrors() []error { return m }

// CGetAllRequestValidationError is the validation error returned by
// CGetAllRequest.Validate if the designated constraints aren't met.
type CGetAllRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetAllRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetAllRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetAllRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetAllRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetAllRequestValidationError) ErrorName() string { return "CGetAllRequestValidationError" }

// Error satisfies the builtin error interface
func (e CGetAllRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetAllRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetAllRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetAllRequestValidationError{}

// Validate checks the field values on CGetByUUIDRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CGetByUUIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetByUUIDRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetByUUIDRequestMultiError, or nil if none found.
func (m *CGetByUUIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetByUUIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCourseUuid()); err != nil {
		err = CGetByUUIDRequestValidationError{
			field:  "CourseUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CGetByUUIDRequestMultiError(errors)
	}

	return nil
}

func (m *CGetByUUIDRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CGetByUUIDRequestMultiError is an error wrapping multiple validation errors
// returned by CGetByUUIDRequest.ValidateAll() if the designated constraints
// aren't met.
type CGetByUUIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetByUUIDRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetByUUIDRequestMultiError) AllErrors() []error { return m }

// CGetByUUIDRequestValidationError is the validation error returned by
// CGetByUUIDRequest.Validate if the designated constraints aren't met.
type CGetByUUIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetByUUIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetByUUIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetByUUIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetByUUIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetByUUIDRequestValidationError) ErrorName() string {
	return "CGetByUUIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CGetByUUIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetByUUIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetByUUIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetByUUIDRequestValidationError{}

// Validate checks the field values on CGetAllWithFilterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetAllWithFilterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetAllWithFilterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetAllWithFilterRequestMultiError, or nil if none found.
func (m *CGetAllWithFilterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetAllWithFilterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CGetAllWithFilterRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CGetAllWithFilterRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	if len(errors) > 0 {
		return CGetAllWithFilterRequestMultiError(errors)
	}

	return nil
}

func (m *CGetAllWithFilterRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CGetAllWithFilterRequestMultiError is an error wrapping multiple validation
// errors returned by CGetAllWithFilterRequest.ValidateAll() if the designated
// constraints aren't met.
type CGetAllWithFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetAllWithFilterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetAllWithFilterRequestMultiError) AllErrors() []error { return m }

// CGetAllWithFilterRequestValidationError is the validation error returned by
// CGetAllWithFilterRequest.Validate if the designated constraints aren't met.
type CGetAllWithFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetAllWithFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetAllWithFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetAllWithFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetAllWithFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetAllWithFilterRequestValidationError) ErrorName() string {
	return "CGetAllWithFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CGetAllWithFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetAllWithFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetAllWithFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetAllWithFilterRequestValidationError{}

// Validate checks the field values on CCreateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CCreateRequestMultiError,
// or nil if none found.
func (m *CCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = CCreateRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CCreateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 300 {
		err := CCreateRequestValidationError{
			field:  "Description",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CCreateRequestMultiError(errors)
	}

	return nil
}

func (m *CCreateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CCreateRequestMultiError is an error wrapping multiple validation errors
// returned by CCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type CCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CCreateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CCreateRequestMultiError) AllErrors() []error { return m }

// CCreateRequestValidationError is the validation error returned by
// CCreateRequest.Validate if the designated constraints aren't met.
type CCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CCreateRequestValidationError) ErrorName() string { return "CCreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e CCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CCreateRequestValidationError{}

// Validate checks the field values on CDeleteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CDeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CDeleteRequestMultiError,
// or nil if none found.
func (m *CDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCourseUuid()); err != nil {
		err = CDeleteRequestValidationError{
			field:  "CourseUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CDeleteRequestMultiError(errors)
	}

	return nil
}

func (m *CDeleteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CDeleteRequestMultiError is an error wrapping multiple validation errors
// returned by CDeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type CDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CDeleteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CDeleteRequestMultiError) AllErrors() []error { return m }

// CDeleteRequestValidationError is the validation error returned by
// CDeleteRequest.Validate if the designated constraints aren't met.
type CDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CDeleteRequestValidationError) ErrorName() string { return "CDeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e CDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CDeleteRequestValidationError{}

// Validate checks the field values on CUpdateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CUpdateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CUpdateRequestMultiError,
// or nil if none found.
func (m *CUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCourseUuid()); err != nil {
		err = CUpdateRequestValidationError{
			field:  "CourseUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CUpdateRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 300 {
		err := CUpdateRequestValidationError{
			field:  "Description",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CUpdateRequestMultiError(errors)
	}

	return nil
}

func (m *CUpdateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CUpdateRequestMultiError is an error wrapping multiple validation errors
// returned by CUpdateRequest.ValidateAll() if the designated constraints
// aren't met.
type CUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CUpdateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CUpdateRequestMultiError) AllErrors() []error { return m }

// CUpdateRequestValidationError is the validation error returned by
// CUpdateRequest.Validate if the designated constraints aren't met.
type CUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CUpdateRequestValidationError) ErrorName() string { return "CUpdateRequestValidationError" }

// Error satisfies the builtin error interface
func (e CUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CUpdateRequestValidationError{}

// Validate checks the field values on CGetAllLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetAllLessonsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetAllLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetAllLessonsRequestMultiError, or nil if none found.
func (m *CGetAllLessonsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetAllLessonsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCourseUuid()); err != nil {
		err = CGetAllLessonsRequestValidationError{
			field:  "CourseUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for Token

	if len(errors) > 0 {
		return CGetAllLessonsRequestMultiError(errors)
	}

	return nil
}

func (m *CGetAllLessonsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CGetAllLessonsRequestMultiError is an error wrapping multiple validation
// errors returned by CGetAllLessonsRequest.ValidateAll() if the designated
// constraints aren't met.
type CGetAllLessonsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetAllLessonsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetAllLessonsRequestMultiError) AllErrors() []error { return m }

// CGetAllLessonsRequestValidationError is the validation error returned by
// CGetAllLessonsRequest.Validate if the designated constraints aren't met.
type CGetAllLessonsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetAllLessonsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetAllLessonsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetAllLessonsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetAllLessonsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetAllLessonsRequestValidationError) ErrorName() string {
	return "CGetAllLessonsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CGetAllLessonsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetAllLessonsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetAllLessonsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetAllLessonsRequestValidationError{}

// Validate checks the field values on CGetByUUIDLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CGetByUUIDLessonsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CGetByUUIDLessonsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CGetByUUIDLessonsRequestMultiError, or nil if none found.
func (m *CGetByUUIDLessonsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CGetByUUIDLessonsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLessonUuid()); err != nil {
		err = CGetByUUIDLessonsRequestValidationError{
			field:  "LessonUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CGetByUUIDLessonsRequestMultiError(errors)
	}

	return nil
}

func (m *CGetByUUIDLessonsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CGetByUUIDLessonsRequestMultiError is an error wrapping multiple validation
// errors returned by CGetByUUIDLessonsRequest.ValidateAll() if the designated
// constraints aren't met.
type CGetByUUIDLessonsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CGetByUUIDLessonsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CGetByUUIDLessonsRequestMultiError) AllErrors() []error { return m }

// CGetByUUIDLessonsRequestValidationError is the validation error returned by
// CGetByUUIDLessonsRequest.Validate if the designated constraints aren't met.
type CGetByUUIDLessonsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CGetByUUIDLessonsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CGetByUUIDLessonsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CGetByUUIDLessonsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CGetByUUIDLessonsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CGetByUUIDLessonsRequestValidationError) ErrorName() string {
	return "CGetByUUIDLessonsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CGetByUUIDLessonsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCGetByUUIDLessonsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CGetByUUIDLessonsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CGetByUUIDLessonsRequestValidationError{}

// Validate checks the field values on CVoteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CVoteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CVoteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CVoteRequestMultiError, or
// nil if none found.
func (m *CVoteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CVoteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCourseUuid()); err != nil {
		err = CVoteRequestValidationError{
			field:  "CourseUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Vote

	// no validation rules for Token

	if len(errors) > 0 {
		return CVoteRequestMultiError(errors)
	}

	return nil
}

func (m *CVoteRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CVoteRequestMultiError is an error wrapping multiple validation errors
// returned by CVoteRequest.ValidateAll() if the designated constraints aren't met.
type CVoteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CVoteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CVoteRequestMultiError) AllErrors() []error { return m }

// CVoteRequestValidationError is the validation error returned by
// CVoteRequest.Validate if the designated constraints aren't met.
type CVoteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CVoteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CVoteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CVoteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CVoteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CVoteRequestValidationError) ErrorName() string { return "CVoteRequestValidationError" }

// Error satisfies the builtin error interface
func (e CVoteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCVoteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CVoteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CVoteRequestValidationError{}

// Validate checks the field values on LessonData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LessonData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LessonData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LessonDataMultiError, or
// nil if none found.
func (m *LessonData) ValidateAll() error {
	return m.validate(true)
}

func (m *LessonData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for MimeType

	if len(errors) > 0 {
		return LessonDataMultiError(errors)
	}

	return nil
}

// LessonDataMultiError is an error wrapping multiple validation errors
// returned by LessonData.ValidateAll() if the designated constraints aren't met.
type LessonDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LessonDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LessonDataMultiError) AllErrors() []error { return m }

// LessonDataValidationError is the validation error returned by
// LessonData.Validate if the designated constraints aren't met.
type LessonDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LessonDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LessonDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LessonDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LessonDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LessonDataValidationError) ErrorName() string { return "LessonDataValidationError" }

// Error satisfies the builtin error interface
func (e LessonDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLessonData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LessonDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LessonDataValidationError{}

// Validate checks the field values on CCreateLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CCreateLessonsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CCreateLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CCreateLessonsRequestMultiError, or nil if none found.
func (m *CCreateLessonsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CCreateLessonsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCourseUuid()); err != nil {
		err = CCreateLessonsRequestValidationError{
			field:  "CourseUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CCreateLessonsRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CCreateLessonsRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CCreateLessonsRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CCreateLessonsRequestValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CCreateLessonsRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CCreateLessonsRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CCreateLessonsRequestValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CCreateLessonsRequestMultiError(errors)
	}

	return nil
}

func (m *CCreateLessonsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CCreateLessonsRequestMultiError is an error wrapping multiple validation
// errors returned by CCreateLessonsRequest.ValidateAll() if the designated
// constraints aren't met.
type CCreateLessonsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CCreateLessonsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CCreateLessonsRequestMultiError) AllErrors() []error { return m }

// CCreateLessonsRequestValidationError is the validation error returned by
// CCreateLessonsRequest.Validate if the designated constraints aren't met.
type CCreateLessonsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CCreateLessonsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CCreateLessonsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CCreateLessonsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CCreateLessonsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CCreateLessonsRequestValidationError) ErrorName() string {
	return "CCreateLessonsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CCreateLessonsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCCreateLessonsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CCreateLessonsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CCreateLessonsRequestValidationError{}

// Validate checks the field values on CDeleteLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CDeleteLessonsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CDeleteLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CDeleteLessonsRequestMultiError, or nil if none found.
func (m *CDeleteLessonsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CDeleteLessonsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLessonUuid()); err != nil {
		err = CDeleteLessonsRequestValidationError{
			field:  "LessonUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CDeleteLessonsRequestMultiError(errors)
	}

	return nil
}

func (m *CDeleteLessonsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CDeleteLessonsRequestMultiError is an error wrapping multiple validation
// errors returned by CDeleteLessonsRequest.ValidateAll() if the designated
// constraints aren't met.
type CDeleteLessonsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CDeleteLessonsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CDeleteLessonsRequestMultiError) AllErrors() []error { return m }

// CDeleteLessonsRequestValidationError is the validation error returned by
// CDeleteLessonsRequest.Validate if the designated constraints aren't met.
type CDeleteLessonsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CDeleteLessonsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CDeleteLessonsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CDeleteLessonsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CDeleteLessonsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CDeleteLessonsRequestValidationError) ErrorName() string {
	return "CDeleteLessonsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CDeleteLessonsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCDeleteLessonsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CDeleteLessonsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CDeleteLessonsRequestValidationError{}

// Validate checks the field values on CUpdateLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CUpdateLessonsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CUpdateLessonsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CUpdateLessonsRequestMultiError, or nil if none found.
func (m *CUpdateLessonsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CUpdateLessonsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLessonUuid()); err != nil {
		err = CUpdateLessonsRequestValidationError{
			field:  "LessonUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) > 60 {
		err := CUpdateLessonsRequestValidationError{
			field:  "Title",
			reason: "value length must be at most 60 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CUpdateLessonsRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CUpdateLessonsRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CUpdateLessonsRequestValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CUpdateLessonsRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CUpdateLessonsRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CUpdateLessonsRequestValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Token

	if len(errors) > 0 {
		return CUpdateLessonsRequestMultiError(errors)
	}

	return nil
}

func (m *CUpdateLessonsRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// CUpdateLessonsRequestMultiError is an error wrapping multiple validation
// errors returned by CUpdateLessonsRequest.ValidateAll() if the designated
// constraints aren't met.
type CUpdateLessonsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CUpdateLessonsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CUpdateLessonsRequestMultiError) AllErrors() []error { return m }

// CUpdateLessonsRequestValidationError is the validation error returned by
// CUpdateLessonsRequest.Validate if the designated constraints aren't met.
type CUpdateLessonsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CUpdateLessonsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CUpdateLessonsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CUpdateLessonsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CUpdateLessonsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CUpdateLessonsRequestValidationError) ErrorName() string {
	return "CUpdateLessonsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CUpdateLessonsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCUpdateLessonsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CUpdateLessonsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CUpdateLessonsRequestValidationError{}

// Validate checks the field values on CountOfPagesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CountOfPagesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountOfPagesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountOfPagesRequestMultiError, or nil if none found.
func (m *CountOfPagesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CountOfPagesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Entity

	// no validation rules for SizeOfPage

	if len(errors) > 0 {
		return CountOfPagesRequestMultiError(errors)
	}

	return nil
}

// CountOfPagesRequestMultiError is an error wrapping multiple validation
// errors returned by CountOfPagesRequest.ValidateAll() if the designated
// constraints aren't met.
type CountOfPagesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountOfPagesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountOfPagesRequestMultiError) AllErrors() []error { return m }

// CountOfPagesRequestValidationError is the validation error returned by
// CountOfPagesRequest.Validate if the designated constraints aren't met.
type CountOfPagesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountOfPagesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountOfPagesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountOfPagesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountOfPagesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountOfPagesRequestValidationError) ErrorName() string {
	return "CountOfPagesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CountOfPagesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountOfPagesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountOfPagesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountOfPagesRequestValidationError{}

// Validate checks the field values on RGetAllRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RGetAllRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RGetAllRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RGetAllRequestMultiError,
// or nil if none found.
func (m *RGetAllRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RGetAllRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return RGetAllRequestMultiError(errors)
	}

	return nil
}

// RGetAllRequestMultiError is an error wrapping multiple validation errors
// returned by RGetAllRequest.ValidateAll() if the designated constraints
// aren't met.
type RGetAllRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RGetAllRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RGetAllRequestMultiError) AllErrors() []error { return m }

// RGetAllRequestValidationError is the validation error returned by
// RGetAllRequest.Validate if the designated constraints aren't met.
type RGetAllRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RGetAllRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RGetAllRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RGetAllRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RGetAllRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RGetAllRequestValidationError) ErrorName() string { return "RGetAllRequestValidationError" }

// Error satisfies the builtin error interface
func (e RGetAllRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRGetAllRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RGetAllRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RGetAllRequestValidationError{}

// Validate checks the field values on RCreateRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RCreateRequestMultiError,
// or nil if none found.
func (m *RCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetCommunityUuid()); err != nil {
		err = RCreateRequestValidationError{
			field:  "CommunityUuid",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMsg()) > 100 {
		err := RCreateRequestValidationError{
			field:  "Msg",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AddressedObj

	// no validation rules for TypeReport

	// no validation rules for Token

	if len(errors) > 0 {
		return RCreateRequestMultiError(errors)
	}

	return nil
}

func (m *RCreateRequest) _validateUuid(uuid string) error {
	if matched := _homie_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// RCreateRequestMultiError is an error wrapping multiple validation errors
// returned by RCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type RCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RCreateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RCreateRequestMultiError) AllErrors() []error { return m }

// RCreateRequestValidationError is the validation error returned by
// RCreateRequest.Validate if the designated constraints aren't met.
type RCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RCreateRequestValidationError) ErrorName() string { return "RCreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e RCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RCreateRequestValidationError{}

// Validate checks the field values on RDeleteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RDeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RDeleteRequestMultiError,
// or nil if none found.
func (m *RDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReportId

	// no validation rules for Token

	if len(errors) > 0 {
		return RDeleteRequestMultiError(errors)
	}

	return nil
}

// RDeleteRequestMultiError is an error wrapping multiple validation errors
// returned by RDeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type RDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RDeleteRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RDeleteRequestMultiError) AllErrors() []error { return m }

// RDeleteRequestValidationError is the validation error returned by
// RDeleteRequest.Validate if the designated constraints aren't met.
type RDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RDeleteRequestValidationError) ErrorName() string { return "RDeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e RDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RDeleteRequestValidationError{}
